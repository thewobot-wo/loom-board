---
phase: 04-mcp-integration
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - mcp-server/package.json
  - mcp-server/tsconfig.json
  - mcp-server/src/index.ts
  - mcp-server/src/convex-client.ts
  - mcp-server/src/tools/read.ts
autonomous: true

must_haves:
  truths:
    - "MCP server starts without errors via tsx"
    - "MCP server registers read tools (list_tasks, get_task, search_tasks, get_board_summary)"
    - "ConvexHttpClient connects to the correct deployment URL"
    - "API token is read from MCP_API_TOKEN environment variable"
  artifacts:
    - path: "mcp-server/package.json"
      provides: "MCP server dependencies and scripts"
      contains: "@modelcontextprotocol/sdk"
    - path: "mcp-server/tsconfig.json"
      provides: "TypeScript config targeting Node.js"
      contains: "NodeNext"
    - path: "mcp-server/src/index.ts"
      provides: "MCP server entry point with StdioServerTransport"
      min_lines: 20
    - path: "mcp-server/src/convex-client.ts"
      provides: "ConvexHttpClient wrapper with auth headers"
      min_lines: 15
    - path: "mcp-server/src/tools/read.ts"
      provides: "Read-only MCP tool registrations"
      min_lines: 80
  key_links:
    - from: "mcp-server/src/convex-client.ts"
      to: "convex/http.ts"
      via: "HTTP fetch to CONVEX_SITE_URL/mcp/* endpoints"
      pattern: "CONVEX_SITE_URL"
    - from: "mcp-server/src/index.ts"
      to: "mcp-server/src/tools/read.ts"
      via: "tool registration import"
      pattern: "import.*read"
---

<objective>
Create the MCP server sub-project with all read-only tools (list_tasks, get_task, search_tasks, get_board_summary). This establishes the project scaffold, ConvexHttpClient wrapper, and the tool registration pattern that Plan 03 will extend with write tools.

Purpose: Claude Code needs to discover and invoke MCP tools. The read tools are the foundation -- Claude needs to see what's on the board before writing to it.
Output: Working `mcp-server/` sub-project with 4 read tools registered
</objective>

<execution_context>
@/Users/criswo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/criswo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-mcp-integration/04-RESEARCH.md
@.planning/phases/04-mcp-integration/04-01-SUMMARY.md
@convex/http.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Scaffold MCP server sub-project with ConvexHttpClient</name>
  <files>mcp-server/package.json, mcp-server/tsconfig.json, mcp-server/src/index.ts, mcp-server/src/convex-client.ts</files>
  <action>
Create `mcp-server/` directory at project root as a separate Node.js sub-project.

**mcp-server/package.json:**
```json
{
  "name": "loom-board-mcp",
  "version": "1.0.0",
  "type": "module",
  "private": true,
  "scripts": {
    "build": "tsc",
    "start": "node build/index.js",
    "dev": "tsx src/index.ts"
  },
  "dependencies": {
    "@modelcontextprotocol/sdk": "^1.25.0",
    "zod": "^3.25.0"
  },
  "devDependencies": {
    "@types/node": "^22.0.0",
    "tsx": "^4.19.0",
    "typescript": "^5.9.0"
  }
}
```

**mcp-server/tsconfig.json:**
Target Node.js (NOT browser). Use NodeNext module resolution:
```json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "NodeNext",
    "moduleResolution": "NodeNext",
    "outDir": "./build",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true
  },
  "include": ["src/**/*"],
  "exclude": ["build"]
}
```

**mcp-server/src/convex-client.ts:**
Create a thin wrapper around fetch that calls the Convex HTTP action endpoints:

1. Read `CONVEX_SITE_URL` and `MCP_API_TOKEN` from `process.env`
2. Validate both exist at startup (throw clear error if missing)
3. Export an async function `callMcpApi(path: string, options?: { method?: string, body?: unknown })` that:
   - Constructs the full URL: `${CONVEX_SITE_URL}${path}` (path like `/mcp/tasks`)
   - Sets headers: `Authorization: Bearer ${MCP_API_TOKEN}`, `Content-Type: application/json`
   - Includes JSON body for POST requests
   - Implements retry logic: retry up to 2 times on network errors (not on 4xx), with 1 second delay between retries
   - Parses JSON response
   - If response is not ok, throws an error with the error message from the response body
   - Returns the parsed JSON data

Do NOT use ConvexHttpClient from the `convex` package. The MCP API uses plain HTTP actions, so a simple fetch wrapper is cleaner and avoids pulling in the full Convex client dependency in the MCP server.

IMPORTANT: Do NOT use console.log anywhere in the MCP server. The stdio transport uses stdout for JSON-RPC. Use console.error for any diagnostic output.

**mcp-server/src/index.ts:**
Entry point that creates the MCP server and starts it:

1. Import `McpServer` from `@modelcontextprotocol/sdk/server/mcp.js`
2. Import `StdioServerTransport` from `@modelcontextprotocol/sdk/server/stdio.js`
3. Create server: `new McpServer({ name: "loom-board", version: "1.0.0" })`
4. Import and call `registerReadTools(server)` from `./tools/read.js` (note .js extension for NodeNext)
5. Connect via stdio: `const transport = new StdioServerTransport(); await server.connect(transport);`
6. Add process error handlers: `process.on('uncaughtException', ...)` logging to stderr

Run `cd mcp-server && npm install` after creating files.
  </action>
  <verify>
Run `cd mcp-server && npm install && npx tsx src/index.ts 2>&1 | head -5` -- it should start without import/compile errors (will error about missing env vars, which is expected). Verify package.json has correct dependencies. Verify tsconfig targets Node.js.
  </verify>
  <done>
`mcp-server/` directory exists with package.json, tsconfig.json, src/index.ts, src/convex-client.ts. Dependencies installed. TypeScript compiles without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement read-only MCP tools</name>
  <files>mcp-server/src/tools/read.ts</files>
  <action>
Create `mcp-server/src/tools/read.ts` that exports a `registerReadTools(server: McpServer)` function registering 4 read tools.

Use `server.tool(name, description, schema, handler)` pattern with Zod schemas for input validation.

**Tool 1: list_tasks**
- Description: "List all active (non-archived) tasks on the board"
- Input schema: `{}` (no parameters)
- Calls: `GET /mcp/tasks`
- Returns: Formatted text listing all tasks grouped by status column. Format each task as:
  ```
  [PRIORITY] Title (ID: xxx)
    Status: backlog | Due: Feb 3, 2026 | Tags: tag1, tag2
  ```
  Group under headers: `## Backlog`, `## In Progress`, `## Blocked`, `## Done`

**Tool 2: get_task**
- Description: "Get full details of a specific task by its ID"
- Input schema: `{ id: z.string().describe("The task ID") }`
- Calls: `GET /mcp/tasks/get?id={id}`
- Returns: Formatted text with all task fields displayed clearly:
  ```
  # Task: {title}
  ID: {id}
  Status: {status}
  Priority: {priority}
  Description: {description or "No description"}
  Tags: {tags.join(", ") or "None"}
  Due Date: {dueDate or "No due date"}
  Created: {createdAt}
  Updated: {updatedAt}
  ```

**Tool 3: search_tasks**
- Description: "Search tasks by text, priority, tags, or due date"
- Input schema:
  ```
  {
    text: z.string().optional().describe("Search text (matches title and description)"),
    priority: z.enum(["low", "medium", "high", "urgent"]).optional().describe("Filter by priority"),
    tags: z.array(z.string()).optional().describe("Filter by tags (OR logic - matches any)"),
    dueDate: z.union([
      z.enum(["overdue", "due-today", "due-this-week", "no-due-date"]).describe("Named preset"),
      z.object({
        dueAfter: z.string().optional().describe("ISO date string"),
        dueBefore: z.string().optional().describe("ISO date string")
      }).describe("Custom date range")
    ]).optional().describe("Due date filter")
  }
  ```
- Calls: `POST /mcp/tasks/search` with the filters as JSON body
- Returns: Formatted list of matching tasks (same format as list_tasks but without grouping)

**Tool 4: get_board_summary**
- Description: "Get a summary of the board with task counts per column and overdue tasks"
- Input schema: `{}` (no parameters)
- Calls: `POST /mcp/board/summary`
- Returns: Formatted summary:
  ```
  # Board Summary
  Total tasks: N

  ## Columns
  Backlog: N tasks
  In Progress: N tasks
  Blocked: N tasks
  Done: N tasks

  ## Overdue Tasks (N)
  - [PRIORITY] Title (due: date)
  ```

**Error handling for all tools:**
- Catch errors from callMcpApi
- Return `{ content: [{ type: "text", text: "Error: {message}" }], isError: true }` on failure
- Return `{ content: [{ type: "text", text: formattedResult }] }` on success

**Important:** MCP tool handlers must return `{ content: [{ type: "text", text: string }] }`. The text should be human-readable markdown-like formatting since Claude will read it.
  </action>
  <verify>
Run `cd mcp-server && npx tsc --noEmit` to verify TypeScript compiles. Verify the file exports `registerReadTools`. Verify all 4 tools are registered with proper Zod schemas.
  </verify>
  <done>
`mcp-server/src/tools/read.ts` exists with 4 registered MCP tools: list_tasks, get_task, search_tasks, get_board_summary. Each tool has Zod input schema, calls the correct Convex HTTP endpoint, and returns formatted text responses.
  </done>
</task>

</tasks>

<verification>
1. `cd mcp-server && npx tsc --noEmit` passes (TypeScript compiles)
2. `mcp-server/src/tools/read.ts` registers exactly 4 tools
3. `mcp-server/src/convex-client.ts` reads env vars and has retry logic
4. `mcp-server/src/index.ts` creates McpServer with StdioServerTransport
5. No console.log calls anywhere in mcp-server (only console.error)
</verification>

<success_criteria>
- MCP server sub-project compiles without TypeScript errors
- 4 read tools registered: list_tasks, get_task, search_tasks, get_board_summary
- ConvexHttpClient wrapper handles auth headers and retries
- All tool outputs are formatted as human-readable text
- No console.log (only console.error for diagnostics)
</success_criteria>

<output>
After completion, create `.planning/phases/04-mcp-integration/04-02-SUMMARY.md`
</output>
