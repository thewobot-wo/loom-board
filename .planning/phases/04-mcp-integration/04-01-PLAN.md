---
phase: 04-mcp-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - convex/mcpApi.ts
  - convex/http.ts
autonomous: true
user_setup:
  - service: convex-env
    why: "MCP API token and user ID must be set as Convex environment variables"
    env_vars:
      - name: MCP_API_TOKEN
        source: "Generate a random token (e.g. openssl rand -hex 32) and set via Convex dashboard -> Settings -> Environment Variables"
      - name: MCP_USER_ID
        source: "Your Convex user ID from the Convex dashboard -> Data -> users table -> copy your _id value"
    dashboard_config:
      - task: "Set MCP_API_TOKEN environment variable"
        location: "Convex Dashboard -> Settings -> Environment Variables"
      - task: "Set MCP_USER_ID environment variable"
        location: "Convex Dashboard -> Settings -> Environment Variables"

must_haves:
  truths:
    - "HTTP endpoints exist for all 8 MCP operations at /mcp/* paths"
    - "Requests with valid API token are accepted and return task data"
    - "Requests with invalid or missing token are rejected with 401"
    - "All operations are scoped to the MCP_USER_ID user's tasks"
  artifacts:
    - path: "convex/mcpApi.ts"
      provides: "HTTP action handlers for all MCP operations with token auth"
      min_lines: 150
    - path: "convex/http.ts"
      provides: "HTTP routes for MCP API endpoints"
      contains: "mcp"
  key_links:
    - from: "convex/mcpApi.ts"
      to: "convex/tasks.ts"
      via: "internal function calls using ctx.runQuery/ctx.runMutation"
      pattern: "ctx\\.run(Query|Mutation)"
    - from: "convex/http.ts"
      to: "convex/mcpApi.ts"
      via: "httpRouter route registration"
      pattern: "http\\.route"
---

<objective>
Create Convex HTTP action endpoints that serve as the authenticated backend API for the MCP server. These HTTP actions validate an API token from the Authorization header, resolve the MCP user identity, and execute task operations on behalf of that user.

Purpose: The MCP server (Plan 02-03) will call these HTTP endpoints via ConvexHttpClient. HTTP actions are used because they have access to process.env for token validation, unlike regular queries/mutations.
Output: `convex/mcpApi.ts` with all 8 operation handlers + updated `convex/http.ts` with routes
</objective>

<execution_context>
@/Users/criswo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/criswo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-mcp-integration/04-CONTEXT.md
@.planning/phases/04-mcp-integration/04-RESEARCH.md
@convex/tasks.ts
@convex/schema.ts
@convex/http.ts
@convex/activityHistory.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create MCP API HTTP actions with token authentication</name>
  <files>convex/mcpApi.ts</files>
  <action>
Create `convex/mcpApi.ts` with HTTP action handlers for all 8 MCP operations. Use Convex `httpAction` from `convex/server`.

**Authentication pattern (use for every handler):**
1. Extract `Authorization: Bearer <token>` from request headers
2. Compare against `process.env.MCP_API_TOKEN` (available in HTTP actions)
3. If missing/invalid, return 401 JSON response `{ error: "Unauthorized" }`
4. Resolve user ID from `process.env.MCP_USER_ID` (cast to Id<"users"> -- note: Convex IDs in env vars are strings, use `as Id<"users">` after importing from `convex/values`)

**Helper function:** Create a `validateToken(request: Request)` helper that returns `{ userId: Id<"users"> }` or throws. Create a `jsonResponse(data, status)` helper for consistent JSON responses with CORS headers.

**8 HTTP action handlers:**

1. `listTasks` (GET) - Query all non-archived tasks for user. Return array with all fields. Format dueDate as human-readable string (e.g., "Feb 3, 2026") using `Intl.DateTimeFormat`. Use `ctx.runQuery(internal.tasks.listTasksInternal, { userId })` -- you'll need to create internal versions of queries.

IMPORTANT: Since existing `convex/tasks.ts` functions use `getAuthUserId` (session-based auth), the MCP API cannot call them directly. Instead, create internal query/mutation functions in `convex/mcpApi.ts` itself that accept `userId` as a parameter and perform the database operations directly. This avoids modifying the existing auth-protected functions.

2. `getTask` (GET) - Accept task ID as query param `?id=<taskId>`. Validate ownership. Return full task object with formatted dates.

3. `createTask` (POST) - Accept JSON body: `{ title, description?, status?, priority?, tags?, dueDate? }`. Default status to "backlog", priority to "medium", tags to []. Validate title is non-empty. Calculate order as max existing order + 1 for the target status column. Return full created task.

4. `updateTask` (POST) - Accept JSON body: `{ id, updates: { title?, description?, status?, priority?, tags?, dueDate? } }`. Validate ownership, validate title non-empty if provided. Log activity history for changed fields. Return updated task.

5. `moveTask` (POST) - Accept JSON body: `{ id, status }`. Shortcut for updating just the status field. Validate ownership. Log activity. Return updated task.

6. `deleteTask` (POST) - Accept JSON body: `{ id }`. Permanently delete the task from the database (not soft delete -- this is per CONTEXT.md where delete and archive are separate). Validate ownership. Return `{ success: true }`.

7. `archiveTask` (POST) - Accept JSON body: `{ id }`. Soft delete (set archived: true). Validate ownership. Log activity. Return `{ success: true }`.

8. `searchTasks` (POST) - Accept JSON body: `{ text?, priority?, tags?, dueDate? }`. `text` matches against title + description (case-insensitive). `priority` filters exact match. `tags` filters tasks that have ANY of the provided tags (OR logic). `dueDate` accepts either a preset string ("overdue", "due-today", "due-this-week", "no-due-date") OR an object `{ dueAfter?, dueBefore? }` with ISO date strings. Combine all filters with AND logic. Return matching tasks array.

9. `getBoardSummary` (POST) - No body needed. Return: `{ columns: { backlog: { count, tasks: [{ id, title, priority }] }, in_progress: {...}, blocked: {...}, done: {...} }, total: N, overdue: { count, tasks: [{ id, title, dueDate }] } }`. Include task titles in summary for usefulness.

**Date formatting:** Create a `formatDate(timestamp: number): string` helper that uses `Intl.DateTimeFormat('en-US', { month: 'short', day: 'numeric', year: 'numeric' })`.

**Error handling:** Wrap each handler in try/catch. Return `{ error: string }` with appropriate HTTP status codes (400 for bad input, 401 for auth, 404 for not found, 500 for server errors). Make error messages helpful (e.g., "Task not found with ID: xyz" not just "Not found").

**CORS headers:** Add `Access-Control-Allow-Origin: *`, `Content-Type: application/json` to all responses.

Note: Since this is 9 handlers (delete and archive are separate per CONTEXT.md), this is a substantial file. Keep each handler focused and use the helper functions to reduce repetition.
  </action>
  <verify>
Run `npx convex dev` and verify it compiles without errors. Check that the file exports all 9 httpAction handlers. Verify the token validation helper is used consistently across all handlers.
  </verify>
  <done>
`convex/mcpApi.ts` exists with 9 HTTP action handlers (listTasks, getTask, createTask, updateTask, moveTask, deleteTask, archiveTask, searchTasks, getBoardSummary), each with token validation and proper error handling.
  </done>
</task>

<task type="auto">
  <name>Task 2: Register MCP HTTP routes in the Convex router</name>
  <files>convex/http.ts</files>
  <action>
Update `convex/http.ts` to add routes for all 9 MCP API endpoints. The existing file already has `auth.addHttpRoutes(http)` -- add MCP routes AFTER auth routes.

**Routes to add:**

```
GET  /mcp/tasks          -> mcpApi.listTasks
GET  /mcp/tasks/get       -> mcpApi.getTask (with ?id= query param)
POST /mcp/tasks/create    -> mcpApi.createTask
POST /mcp/tasks/update    -> mcpApi.updateTask
POST /mcp/tasks/move      -> mcpApi.moveTask
POST /mcp/tasks/delete    -> mcpApi.deleteTask
POST /mcp/tasks/archive   -> mcpApi.archiveTask
POST /mcp/tasks/search    -> mcpApi.searchTasks
POST /mcp/board/summary   -> mcpApi.getBoardSummary
```

Import the handlers from `./mcpApi`. Use `http.route({ path: "/mcp/tasks", method: "GET", handler: listTasks })` pattern.

Also add CORS preflight handling: Register an OPTIONS handler for each path that returns 204 with appropriate CORS headers (Access-Control-Allow-Origin: *, Access-Control-Allow-Methods, Access-Control-Allow-Headers: Authorization, Content-Type).

Keep the existing auth routes intact. The file should still export the http router as default.
  </action>
  <verify>
Run `npx convex dev` and verify deployment succeeds without errors. Verify the http.ts file has all 9 route registrations. Count route registrations to confirm 9 MCP routes + OPTIONS handlers.
  </verify>
  <done>
`convex/http.ts` registers all 9 MCP API routes under `/mcp/*` paths with CORS preflight support. Existing auth routes remain intact. Convex deployment succeeds.
  </done>
</task>

</tasks>

<verification>
1. `npx convex dev` deploys successfully with the new HTTP actions
2. All 9 routes are registered in http.ts
3. Token validation pattern is consistent across all handlers
4. Response format includes formatted dates for human readability
</verification>

<success_criteria>
- convex/mcpApi.ts exists with 9 HTTP action handlers
- convex/http.ts has 9 MCP route registrations + CORS preflight
- Convex deployment succeeds without type errors
- Each handler validates the API token before proceeding
- Error responses use appropriate HTTP status codes
</success_criteria>

<output>
After completion, create `.planning/phases/04-mcp-integration/04-01-SUMMARY.md`
</output>
