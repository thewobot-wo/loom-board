---
phase: 02-react-frontend
plan: 03
type: execute
wave: 3
depends_on: ["02-02"]
files_modified:
  - package.json
  - src/components/Board/Board.tsx
  - src/components/Task/SortableTaskCard.tsx
  - src/components/Task/TaskCard.module.css
  - src/components/Task/index.ts
  - src/hooks/useTaskMutations.ts
  - src/hooks/index.ts
autonomous: true

must_haves:
  truths:
    - "User can drag a task card and drop it in a different column"
    - "Task visually moves to new column immediately (optimistic update)"
    - "Task status persists after page refresh (Convex updated)"
    - "Drag feedback shows elevated card with shadow"
  artifacts:
    - path: "src/components/Task/SortableTaskCard.tsx"
      provides: "Draggable task card with useSortable"
      contains: "useSortable"
    - path: "src/hooks/useTaskMutations.ts"
      provides: "Mutation hook with optimistic updates"
      contains: "withOptimisticUpdate"
    - path: "src/components/Board/Board.tsx"
      provides: "DndContext with drag handlers"
      contains: "DndContext"
  key_links:
    - from: "src/components/Board/Board.tsx"
      to: "DndContext"
      via: "onDragEnd handler"
      pattern: "onDragEnd.*updateTask"
    - from: "src/hooks/useTaskMutations.ts"
      to: "api.tasks.updateTask"
      via: "useMutation with optimistic update"
      pattern: "withOptimisticUpdate"
---

<objective>
Implement drag-and-drop between columns using dnd-kit with optimistic updates.

Purpose: Enable the core Kanban interaction - dragging tasks between columns with instant visual feedback and server persistence.

Output: Fully functional drag-and-drop that feels instant (optimistic) and persists to Convex.
</objective>

<execution_context>
@/Users/criswo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/criswo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/02-react-frontend/02-CONTEXT.md
@.planning/phases/02-react-frontend/02-RESEARCH.md
@.planning/phases/02-react-frontend/02-02-SUMMARY.md
@convex/tasks.ts (updateTask mutation)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dnd-kit and create SortableTaskCard</name>
  <files>
    package.json
    src/components/Task/SortableTaskCard.tsx
    src/components/Task/TaskCard.module.css
    src/components/Task/index.ts
  </files>
  <action>
Install dnd-kit packages:
```bash
npm install @dnd-kit/core @dnd-kit/sortable @dnd-kit/utilities
```

Create src/components/Task/SortableTaskCard.tsx:
```typescript
import { useSortable } from "@dnd-kit/sortable";
import { CSS } from "@dnd-kit/utilities";
import type { Doc } from "../../../convex/_generated/dataModel";
import { TaskCard } from "./TaskCard";
import styles from "./TaskCard.module.css";

interface SortableTaskCardProps {
  task: Doc<"tasks">;
  onEdit?: (taskId: string) => void;
}

export function SortableTaskCard({ task, onEdit }: SortableTaskCardProps) {
  const {
    attributes,
    listeners,
    setNodeRef,
    transform,
    transition,
    isDragging,
  } = useSortable({ id: task._id });

  const style = {
    transform: CSS.Transform.toString(transform),
    transition,
    opacity: isDragging ? 0.5 : 1,
    zIndex: isDragging ? 1000 : 1,
  };

  return (
    <div
      ref={setNodeRef}
      style={style}
      className={isDragging ? styles.dragging : undefined}
      {...attributes}
      {...listeners}
    >
      <TaskCard task={task} isDragging={isDragging} onEdit={onEdit} />
    </div>
  );
}
```

Add drag overlay styles to src/components/Task/TaskCard.module.css:
```css
/* Add to existing file */

.dragOverlay {
  background: var(--bg-tertiary);
  border: 1px solid var(--accent-blue);
  border-radius: var(--radius-sm);
  padding: 14px;
  box-shadow: var(--shadow-hover);
  transform: rotate(3deg);
  cursor: grabbing;
}
```

Update src/components/Task/index.ts:
```typescript
export { TaskCard } from "./TaskCard";
export { SortableTaskCard } from "./SortableTaskCard";
export { TaskSkeleton } from "./TaskSkeleton";
```
  </action>
  <verify>
- `npx tsc --noEmit` passes
- `ls src/components/Task/SortableTaskCard.tsx` exists
- `npm ls @dnd-kit/core` shows installed
  </verify>
  <done>
SortableTaskCard wraps TaskCard with useSortable hook for drag-and-drop capability.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create useTaskMutations hook with optimistic updates</name>
  <files>
    src/hooks/useTaskMutations.ts
    src/hooks/index.ts
  </files>
  <action>
Create src/hooks/useTaskMutations.ts:
```typescript
import { useMutation } from "convex/react";
import { api } from "../../convex/_generated/api";
import type { Id } from "../../convex/_generated/dataModel";
import type { Status, Priority } from "@/lib/constants";

export interface TaskUpdates {
  title?: string;
  description?: string;
  status?: Status;
  priority?: Priority;
  tags?: string[];
  dueDate?: number;
  order?: number;
}

export function useTaskMutations() {
  // Update task with optimistic update for status changes (drag-drop)
  const updateTask = useMutation(api.tasks.updateTask).withOptimisticUpdate(
    (localStore, args) => {
      // Only apply optimistic update for status changes (drag-drop)
      if (!args.updates.status) return;

      const currentTasks = localStore.getQuery(api.tasks.listTasks, {});
      if (currentTasks === undefined) return;

      // Find and update the task locally
      const updatedTasks = currentTasks.map((task) =>
        task._id === args.id
          ? { ...task, status: args.updates.status!, updatedAt: Date.now() }
          : task
      );

      localStore.setQuery(api.tasks.listTasks, {}, updatedTasks);
    }
  );

  // Create task (no optimistic update - wait for server ID)
  const createTask = useMutation(api.tasks.createTask);

  // Archive task with optimistic update
  const archiveTask = useMutation(api.tasks.archiveTask).withOptimisticUpdate(
    (localStore, args) => {
      const currentTasks = localStore.getQuery(api.tasks.listTasks, {});
      if (currentTasks === undefined) return;

      // Remove task from list (archived tasks are filtered out)
      const updatedTasks = currentTasks.filter((task) => task._id !== args.id);
      localStore.setQuery(api.tasks.listTasks, {}, updatedTasks);
    }
  );

  // Restore task (no optimistic update - task not in current list)
  const restoreTask = useMutation(api.tasks.restoreTask);

  return {
    updateTask,
    createTask,
    archiveTask,
    restoreTask,
  };
}
```

Create src/hooks/index.ts:
```typescript
export { useTaskMutations } from "./useTaskMutations";
export type { TaskUpdates } from "./useTaskMutations";
```
  </action>
  <verify>
- `npx tsc --noEmit` passes
- `ls src/hooks/useTaskMutations.ts` exists
  </verify>
  <done>
useTaskMutations hook provides mutations with optimistic updates for instant UI feedback.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate DndContext in Board with drag handlers</name>
  <files>
    src/components/Board/Board.tsx
    src/components/Column/Column.tsx
  </files>
  <action>
Update src/components/Board/Board.tsx to add DndContext:
```typescript
import { useState, useCallback } from "react";
import {
  DndContext,
  DragOverlay,
  closestCorners,
  PointerSensor,
  KeyboardSensor,
  useSensor,
  useSensors,
  type DragStartEvent,
  type DragEndEvent,
  type DragOverEvent,
} from "@dnd-kit/core";
import { sortableKeyboardCoordinates } from "@dnd-kit/sortable";
import { useQuery } from "convex/react";
import { api } from "../../../convex/_generated/api";
import type { Doc, Id } from "../../../convex/_generated/dataModel";
import { COLUMN_ORDER, STATUS_CONFIG, type Status } from "@/lib/constants";
import { useTaskMutations } from "@/hooks";
import { Column, ColumnSkeleton } from "@/components/Column";
import { TaskCard } from "@/components/Task";
import styles from "./Board.module.css";

interface BoardProps {
  onAddTask?: (status: Status) => void;
  onEditTask?: (taskId: string) => void;
}

export function Board({ onAddTask, onEditTask }: BoardProps) {
  const tasks = useQuery(api.tasks.listTasks);
  const { updateTask } = useTaskMutations();
  const [activeTask, setActiveTask] = useState<Doc<"tasks"> | null>(null);

  const sensors = useSensors(
    useSensor(PointerSensor, {
      activationConstraint: {
        distance: 8, // 8px movement before drag starts
      },
    }),
    useSensor(KeyboardSensor, {
      coordinateGetter: sortableKeyboardCoordinates,
    })
  );

  const handleDragStart = useCallback((event: DragStartEvent) => {
    const { active } = event;
    const task = tasks?.find((t) => t._id === active.id);
    if (task) {
      setActiveTask(task);
    }
  }, [tasks]);

  const handleDragEnd = useCallback(
    async (event: DragEndEvent) => {
      const { active, over } = event;
      setActiveTask(null);

      if (!over) return;

      const taskId = active.id as Id<"tasks">;
      const task = tasks?.find((t) => t._id === taskId);
      if (!task) return;

      // Determine target status from over.id
      // over.id could be a column ID (status) or another task ID
      let targetStatus: Status;

      if (COLUMN_ORDER.includes(over.id as Status)) {
        // Dropped on column directly
        targetStatus = over.id as Status;
      } else {
        // Dropped on another task - find that task's status
        const overTask = tasks?.find((t) => t._id === over.id);
        if (!overTask) return;
        targetStatus = overTask.status as Status;
      }

      // Only update if status changed
      if (task.status !== targetStatus) {
        await updateTask({
          id: taskId,
          updates: { status: targetStatus },
        });
      }
    },
    [tasks, updateTask]
  );

  // Loading state
  if (tasks === undefined) {
    return (
      <div className={styles.container}>
        <div className={styles.loading}>
          {COLUMN_ORDER.map((status) => (
            <ColumnSkeleton key={status} />
          ))}
        </div>
      </div>
    );
  }

  // Group tasks by status and sort by order within each column
  const tasksByStatus = COLUMN_ORDER.reduce(
    (acc, status) => {
      acc[status] = tasks
        .filter((t) => t.status === status)
        .sort((a, b) => a.order - b.order);
      return acc;
    },
    {} as Record<Status, Doc<"tasks">[]>
  );

  return (
    <DndContext
      sensors={sensors}
      collisionDetection={closestCorners}
      onDragStart={handleDragStart}
      onDragEnd={handleDragEnd}
    >
      <div className={styles.container}>
        <div className={styles.board}>
          {COLUMN_ORDER.map((status) => (
            <Column
              key={status}
              status={status}
              tasks={tasksByStatus[status]}
              onAddTask={onAddTask}
              onEditTask={onEditTask}
            />
          ))}
        </div>
      </div>

      <DragOverlay>
        {activeTask ? (
          <div className={styles.dragOverlay}>
            <TaskCard task={activeTask} isDragging />
          </div>
        ) : null}
      </DragOverlay>
    </DndContext>
  );
}
```

Add drag overlay styles to src/components/Board/Board.module.css:
```css
/* Add to existing file */

.dragOverlay {
  transform: rotate(3deg);
  box-shadow: var(--shadow-hover);
}
```

Update src/components/Column/Column.tsx to use SortableContext:
```typescript
import { useDroppable } from "@dnd-kit/core";
import {
  SortableContext,
  verticalListSortingStrategy,
} from "@dnd-kit/sortable";
import type { Doc } from "../../../convex/_generated/dataModel";
import { STATUS_CONFIG, type Status } from "@/lib/constants";
import { SortableTaskCard } from "@/components/Task";
import styles from "./Column.module.css";

interface ColumnProps {
  status: Status;
  tasks: Doc<"tasks">[];
  onAddTask?: (status: Status) => void;
  onEditTask?: (taskId: string) => void;
}

export function Column({ status, tasks, onAddTask, onEditTask }: ColumnProps) {
  const config = STATUS_CONFIG[status];
  const showAddButton = status !== "done";

  const { setNodeRef, isOver } = useDroppable({
    id: status,
  });

  const taskIds = tasks.map((t) => t._id);

  return (
    <div className={styles.column}>
      <div className={styles.header}>
        <span className={styles.title} style={{ color: config.color }}>
          <span className={styles.icon} style={{ background: config.color }} />
          {config.label}
        </span>
        <span className={styles.count}>{tasks.length}</span>
      </div>
      <div
        ref={setNodeRef}
        className={`${styles.taskList} ${isOver ? styles.dragOver : ""}`}
      >
        <SortableContext items={taskIds} strategy={verticalListSortingStrategy}>
          {tasks.map((task) => (
            <SortableTaskCard
              key={task._id}
              task={task}
              onEdit={onEditTask}
            />
          ))}
        </SortableContext>
      </div>
      {showAddButton && (
        <button
          className={styles.addButton}
          onClick={() => onAddTask?.(status)}
        >
          + Add Task
        </button>
      )}
    </div>
  );
}
```
  </action>
  <verify>
- `npm run dev` - drag a task between columns
- Task visually moves immediately (optimistic update)
- Refresh page - task remains in new column (persisted to Convex)
- `npx tsc --noEmit` passes
  </verify>
  <done>
Drag-and-drop works between columns with instant optimistic updates and Convex persistence.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. Drag a task from Backlog to In Progress - moves immediately
2. Drag shows elevated card with rotation (DragOverlay)
3. Drop on column or on another task - both work
4. Column highlights when dragging over (dragOver style)
5. Refresh page - task persists in new column
6. Keyboard drag works (Tab to task, Space to pick up, arrows to move, Space to drop)
</verification>

<success_criteria>
- Drag-and-drop between all 4 columns works
- Optimistic update provides instant visual feedback
- Task status persists after refresh
- Drag feedback (rotation, shadow, opacity) matches design
- TypeScript compiles with no errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-react-frontend/02-03-SUMMARY.md`
</output>
