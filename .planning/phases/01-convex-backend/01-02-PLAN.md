---
phase: 01-convex-backend
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - convex/tasks.ts
  - convex/activityHistory.ts
  - convex/crons.ts
autonomous: true

must_haves:
  truths:
    - "Tasks can be created via Convex dashboard with all required fields"
    - "Tasks can be read, filtered by status, and sorted by order"
    - "Tasks can be updated with partial fields, tracking changes in history"
    - "Tasks can be soft-deleted (archived) and restored"
    - "Activity history records all field changes with old/new values"
    - "Old activity history records are cleaned up after 90 days"
  artifacts:
    - path: "convex/tasks.ts"
      provides: "Task CRUD operations"
      exports: ["createTask", "getTask", "listTasks", "listTasksByStatus", "updateTask", "archiveTask", "restoreTask"]
    - path: "convex/activityHistory.ts"
      provides: "Activity tracking and cleanup"
      exports: ["getTaskHistory", "cleanupOldRecords"]
    - path: "convex/crons.ts"
      provides: "Scheduled cleanup job"
      exports: ["default"]
  key_links:
    - from: "convex/tasks.ts"
      to: "convex/activityHistory.ts"
      via: "updateTask calls ctx.db.insert for activity_history"
      pattern: "ctx\\.db\\.insert.*activity_history"
    - from: "convex/crons.ts"
      to: "convex/activityHistory.ts"
      via: "cron schedules cleanupOldRecords"
      pattern: "internal\\.activityHistory\\.cleanupOldRecords"
---

<objective>
Implement task CRUD operations and activity history tracking with scheduled cleanup.

Purpose: Complete the backend API that makes tasks manageable via Convex dashboard and later via frontend/MCP. Activity tracking enables audit trail for all changes.

Output: Full CRUD mutations/queries for tasks with automatic change logging and 90-day cleanup.
</objective>

<execution_context>
@/Users/criswo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/criswo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-convex-backend/01-CONTEXT.md
@.planning/phases/01-convex-backend/01-RESEARCH.md
@.planning/phases/01-convex-backend/01-01-SUMMARY.md
@convex/schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Task CRUD Operations</name>
  <files>convex/tasks.ts</files>
  <action>
Create `convex/tasks.ts` with complete CRUD operations per CONTEXT.md decisions:

```typescript
import { mutation, query } from "./_generated/server";
import { v } from "convex/values";
import { statusValidator, priorityValidator } from "./schema";

// CREATE: Returns full task object with all fields
export const createTask = mutation({
  args: {
    title: v.string(),
    description: v.optional(v.string()),
    status: statusValidator,
    priority: priorityValidator,
    tags: v.array(v.string()),
    dueDate: v.optional(v.number()),
    order: v.number(),
  },
  handler: async (ctx, args) => {
    // Strict validation: title cannot be empty
    if (args.title.trim() === "") {
      throw new Error("Title cannot be empty");
    }

    const now = Date.now();
    const taskId = await ctx.db.insert("tasks", {
      ...args,
      title: args.title.trim(),
      archived: false,
      updatedAt: now,
    });

    // Log creation in activity history
    await ctx.db.insert("activity_history", {
      taskId,
      field: "_created",
      oldValue: undefined,
      newValue: JSON.stringify({ title: args.title, status: args.status }),
      userId: undefined, // Will be populated in Phase 3
    });

    // Return full task object
    return await ctx.db.get(taskId);
  },
});

// READ: Get single task by ID
export const getTask = query({
  args: { id: v.id("tasks") },
  handler: async (ctx, args) => {
    const task = await ctx.db.get(args.id);
    if (!task) {
      throw new Error("Task not found");
    }
    return task;
  },
});

// READ: List all non-archived tasks
export const listTasks = query({
  args: {},
  handler: async (ctx) => {
    return await ctx.db
      .query("tasks")
      .withIndex("by_archived", (q) => q.eq("archived", false))
      .collect();
  },
});

// READ: List tasks by status, ordered by 'order' field
export const listTasksByStatus = query({
  args: { status: statusValidator },
  handler: async (ctx, args) => {
    return await ctx.db
      .query("tasks")
      .withIndex("by_status_order", (q) => q.eq("status", args.status))
      .filter((q) => q.eq(q.field("archived"), false))
      .collect();
  },
});

// UPDATE: Partial updates with activity tracking
export const updateTask = mutation({
  args: {
    id: v.id("tasks"),
    updates: v.object({
      title: v.optional(v.string()),
      description: v.optional(v.string()),
      status: v.optional(statusValidator),
      priority: v.optional(priorityValidator),
      tags: v.optional(v.array(v.string())),
      dueDate: v.optional(v.number()),
      order: v.optional(v.number()),
    }),
  },
  handler: async (ctx, args) => {
    const existing = await ctx.db.get(args.id);
    if (!existing) {
      throw new Error("Task not found");
    }
    if (existing.archived) {
      throw new Error("Cannot update archived task");
    }

    // Validate title if provided
    if (args.updates.title !== undefined && args.updates.title.trim() === "") {
      throw new Error("Title cannot be empty");
    }

    // Track ALL field changes in activity history (per CONTEXT.md)
    const updateKeys = Object.keys(args.updates) as Array<keyof typeof args.updates>;
    for (const field of updateKeys) {
      const newValue = args.updates[field];
      if (newValue === undefined) continue;

      const oldValue = existing[field as keyof typeof existing];

      // Only log if value actually changed
      if (JSON.stringify(oldValue) !== JSON.stringify(newValue)) {
        await ctx.db.insert("activity_history", {
          taskId: args.id,
          field,
          oldValue: oldValue !== undefined ? JSON.stringify(oldValue) : undefined,
          newValue: JSON.stringify(newValue),
          userId: undefined, // Will be populated in Phase 3
        });
      }
    }

    // Apply partial update
    const cleanUpdates: Record<string, any> = { updatedAt: Date.now() };
    for (const [key, value] of Object.entries(args.updates)) {
      if (value !== undefined) {
        cleanUpdates[key] = key === "title" ? (value as string).trim() : value;
      }
    }

    await ctx.db.patch(args.id, cleanUpdates);
    return await ctx.db.get(args.id);
  },
});

// DELETE (soft): Archive task
export const archiveTask = mutation({
  args: { id: v.id("tasks") },
  handler: async (ctx, args) => {
    const task = await ctx.db.get(args.id);
    if (!task) {
      throw new Error("Task not found");
    }

    await ctx.db.patch(args.id, {
      archived: true,
      updatedAt: Date.now(),
    });

    // Log archive action
    await ctx.db.insert("activity_history", {
      taskId: args.id,
      field: "archived",
      oldValue: JSON.stringify(false),
      newValue: JSON.stringify(true),
      userId: undefined,
    });

    return { success: true };
  },
});

// RESTORE: Unarchive task back to backlog
export const restoreTask = mutation({
  args: { id: v.id("tasks") },
  handler: async (ctx, args) => {
    const task = await ctx.db.get(args.id);
    if (!task) {
      throw new Error("Task not found");
    }
    if (!task.archived) {
      throw new Error("Task is not archived");
    }

    await ctx.db.patch(args.id, {
      archived: false,
      status: "backlog", // Restored tasks go to backlog
      updatedAt: Date.now(),
    });

    // Log restore action
    await ctx.db.insert("activity_history", {
      taskId: args.id,
      field: "archived",
      oldValue: JSON.stringify(true),
      newValue: JSON.stringify(false),
      userId: undefined,
    });

    return await ctx.db.get(args.id);
  },
});
```

Key implementation decisions:
- Strict validation throws errors with descriptive messages (Convex-idiomatic)
- createTask returns full task object
- updateTask accepts partial updates, only changes provided fields
- All changes tracked in activity_history with JSON-stringified values
- Soft delete via archived flag, restore returns to backlog
  </action>
  <verify>
    - `npx convex dev` shows no TypeScript errors
    - In Convex dashboard Functions tab, all exports appear:
      - tasks:createTask
      - tasks:getTask
      - tasks:listTasks
      - tasks:listTasksByStatus
      - tasks:updateTask
      - tasks:archiveTask
      - tasks:restoreTask
  </verify>
  <done>Task CRUD operations deployed with validation and activity tracking</done>
</task>

<task type="auto">
  <name>Task 2: Implement Activity History Queries and Cleanup</name>
  <files>
    - convex/activityHistory.ts
    - convex/crons.ts
  </files>
  <action>
Create `convex/activityHistory.ts` for querying history and cleanup:

```typescript
import { query, internalMutation } from "./_generated/server";
import { v } from "convex/values";

// Query history for a specific task
export const getTaskHistory = query({
  args: { taskId: v.id("tasks") },
  handler: async (ctx, args) => {
    return await ctx.db
      .query("activity_history")
      .withIndex("by_task", (q) => q.eq("taskId", args.taskId))
      .order("desc") // Most recent first
      .collect();
  },
});

// Query recent activity across all tasks (for activity panel)
export const getRecentActivity = query({
  args: { limit: v.optional(v.number()) },
  handler: async (ctx, args) => {
    const limit = args.limit ?? 50;
    const activities = await ctx.db
      .query("activity_history")
      .withIndex("by_creation")
      .order("desc")
      .take(limit);

    // Enrich with task titles
    const enriched = await Promise.all(
      activities.map(async (activity) => {
        const task = await ctx.db.get(activity.taskId);
        return {
          ...activity,
          taskTitle: task?.title ?? "[Deleted Task]",
        };
      })
    );

    return enriched;
  },
});

// Internal mutation for cleanup (called by cron, not exposed publicly)
export const cleanupOldRecords = internalMutation({
  args: {},
  handler: async (ctx) => {
    // 90 days in milliseconds
    const ninetyDaysAgo = Date.now() - (90 * 24 * 60 * 60 * 1000);

    // Query old records (batch of 1000 to avoid timeout)
    const oldRecords = await ctx.db
      .query("activity_history")
      .withIndex("by_creation")
      .filter((q) => q.lt(q.field("_creationTime"), ninetyDaysAgo))
      .take(1000);

    // Delete each record
    let deletedCount = 0;
    for (const record of oldRecords) {
      await ctx.db.delete(record._id);
      deletedCount++;
    }

    console.log(`Activity history cleanup: deleted ${deletedCount} records older than 90 days`);
    return { deletedCount };
  },
});
```

Create `convex/crons.ts` for scheduled cleanup:

```typescript
import { cronJobs } from "convex/server";
import { internal } from "./_generated/api";

const crons = cronJobs();

// Run cleanup daily at 2 AM UTC
// Per CONTEXT.md: retain history for 90 days
crons.daily(
  "cleanup old activity history",
  { hourUTC: 2, minuteUTC: 0 },
  internal.activityHistory.cleanupOldRecords
);

export default crons;
```

Key implementation decisions:
- cleanupOldRecords is `internalMutation` (not callable from client - security)
- Batch size of 1000 per run to avoid function timeout
- Daily cleanup at 2 AM UTC
- getRecentActivity enriches with task title for display
  </action>
  <verify>
    - `npx convex dev` shows no errors
    - Dashboard shows cron job registered under "Scheduled Jobs"
    - Dashboard Functions tab shows:
      - activityHistory:getTaskHistory
      - activityHistory:getRecentActivity
      - activityHistory:cleanupOldRecords (internal - not in public API)
  </verify>
  <done>Activity history queries and 90-day cleanup cron deployed</done>
</task>

<task type="auto">
  <name>Task 3: Verify Full CRUD via Dashboard</name>
  <files>None (verification only)</files>
  <action>
Test the complete CRUD flow via Convex dashboard:

1. **Open dashboard:** `npx convex dashboard` or use URL from terminal

2. **Create a task:**
   - Navigate to Functions > tasks:createTask
   - Enter test arguments:
   ```json
   {
     "title": "Test task from dashboard",
     "status": "backlog",
     "priority": "medium",
     "tags": ["test", "verification"],
     "order": 1
   }
   ```
   - Click Run, verify it returns full task object with _id

3. **Read tasks:**
   - Run tasks:listTasks - should show the created task
   - Run tasks:listTasksByStatus with {"status": "backlog"} - should include task

4. **Update task:**
   - Run tasks:updateTask with:
   ```json
   {
     "id": "[paste _id from create]",
     "updates": {
       "status": "in_progress",
       "priority": "high"
     }
   }
   ```
   - Verify response shows updated fields

5. **Check activity history:**
   - Navigate to Data > activity_history table
   - Should see entries for: _created, status change, priority change
   - Each entry has oldValue/newValue

6. **Archive and restore:**
   - Run tasks:archiveTask with the task ID
   - Run tasks:listTasks - task should NOT appear
   - Run tasks:restoreTask - task should return to backlog

7. **Cleanup test:**
   - Note: Cron won't run immediately. Verify it's registered in Scheduled Jobs
   - The cleanupOldRecords function is internal (won't show in Functions dropdown for public calls)
  </action>
  <verify>
    - Task created with all fields populated
    - Task appears in listTasks and listTasksByStatus
    - Update modifies only specified fields, creates history entries
    - Archive removes from active list, restore brings back
    - Activity history table contains change records
    - Cron job visible in Scheduled Jobs section
  </verify>
  <done>Full CRUD cycle verified: create, read, update, archive, restore all working via dashboard</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Functions deployed:**
   ```
   tasks:createTask
   tasks:getTask
   tasks:listTasks
   tasks:listTasksByStatus
   tasks:updateTask
   tasks:archiveTask
   tasks:restoreTask
   activityHistory:getTaskHistory
   activityHistory:getRecentActivity
   ```

2. **Data integrity:**
   - Create task -> appears in Data > tasks
   - Update task -> activity_history gets new entry
   - Archive task -> archived: true, still in DB
   - Restore task -> archived: false, status: backlog

3. **Cron registered:**
   - Dashboard > Scheduled Jobs shows "cleanup old activity history"
   - Next run time displayed (daily at 02:00 UTC)

4. **Error handling:**
   - Try createTask with empty title -> throws "Title cannot be empty"
   - Try getTask with invalid ID -> throws "Task not found"
   - Try updateTask on archived task -> throws "Cannot update archived task"
</verification>

<success_criteria>
- [ ] convex/tasks.ts exports 7 CRUD functions
- [ ] convex/activityHistory.ts exports 2 queries + 1 internal mutation
- [ ] convex/crons.ts registers daily cleanup job
- [ ] Tasks can be created with validation (empty title rejected)
- [ ] Tasks can be updated with partial fields
- [ ] All field changes create activity_history entries
- [ ] Archived tasks excluded from listTasks
- [ ] Cron job visible in Convex dashboard
</success_criteria>

<output>
After completion, create `.planning/phases/01-convex-backend/01-02-SUMMARY.md`
</output>
