---
phase: 03-authentication
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - convex/tasks.ts
autonomous: true

must_haves:
  truths:
    - "Unauthenticated calls to task functions throw error"
    - "Users can only read their own tasks"
    - "Users can only modify their own tasks"
    - "New tasks are automatically assigned to authenticated user"
  artifacts:
    - path: "convex/tasks.ts"
      provides: "Auth-protected task CRUD functions"
      contains: "getAuthUserId"
  key_links:
    - from: "convex/tasks.ts"
      to: "convex/auth.ts"
      via: "getAuthUserId import"
      pattern: "getAuthUserId"
    - from: "convex/tasks.ts"
      to: "convex/schema.ts"
      via: "userId field usage"
      pattern: "userId.*eq"
---

<objective>
Protect all Convex task functions with authentication

Purpose: Without auth protection, any user could read/modify any task. This plan ensures SEC-03 (all functions validate auth) and AUTH-04 (only owner can access).
Output: All task queries filter by userId, all mutations validate userId ownership, new tasks auto-assigned to authenticated user
</objective>

<execution_context>
@/Users/criswo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/criswo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-authentication/03-RESEARCH.md
@.planning/phases/03-authentication/03-01-SUMMARY.md
@convex/tasks.ts
@convex/schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add auth validation to all query functions</name>
  <files>convex/tasks.ts</files>
  <action>
1. Import getAuthUserId from @convex-dev/auth/server at top of file:
   ```typescript
   import { getAuthUserId } from "@convex-dev/auth/server";
   ```

2. Update `getTask` query to validate auth and ownership:
   ```typescript
   export const getTask = query({
     args: { id: v.id("tasks") },
     handler: async (ctx, args) => {
       const userId = await getAuthUserId(ctx);
       if (!userId) throw new Error("Not authenticated");

       const task = await ctx.db.get(args.id);
       if (!task) throw new Error("Task not found");
       if (task.userId !== userId) throw new Error("Not authorized");
       return task;
     },
   });
   ```

3. Update `listTasks` query to filter by authenticated user:
   ```typescript
   export const listTasks = query({
     args: {},
     handler: async (ctx) => {
       const userId = await getAuthUserId(ctx);
       if (!userId) throw new Error("Not authenticated");

       return await ctx.db
         .query("tasks")
         .withIndex("by_user", (q) => q.eq("userId", userId))
         .filter((q) => q.eq(q.field("archived"), false))
         .collect();
     },
   });
   ```

4. Update `listTasksByStatus` query with auth + user filter:
   ```typescript
   export const listTasksByStatus = query({
     args: { status: statusValidator },
     handler: async (ctx, args) => {
       const userId = await getAuthUserId(ctx);
       if (!userId) throw new Error("Not authenticated");

       // Query by user first (indexed), then filter by status and archived
       return await ctx.db
         .query("tasks")
         .withIndex("by_user", (q) => q.eq("userId", userId))
         .filter((q) =>
           q.and(
             q.eq(q.field("status"), args.status),
             q.eq(q.field("archived"), false)
           )
         )
         .collect();
     },
   });
   ```

5. Update `listArchivedTasks` query with auth + user filter:
   ```typescript
   export const listArchivedTasks = query({
     args: {},
     handler: async (ctx) => {
       const userId = await getAuthUserId(ctx);
       if (!userId) throw new Error("Not authenticated");

       return await ctx.db
         .query("tasks")
         .withIndex("by_user", (q) => q.eq("userId", userId))
         .filter((q) => q.eq(q.field("archived"), true))
         .collect();
     },
   });
   ```

Pattern: Every query now:
1. Gets userId via getAuthUserId(ctx)
2. Throws "Not authenticated" if null
3. Filters/validates by userId
  </action>
  <verify>
    - `npx convex dev --once` compiles without errors
    - All query functions have `getAuthUserId(ctx)` call
    - All queries filter by userId
  </verify>
  <done>
    - getTask validates ownership
    - listTasks filters by authenticated user
    - listTasksByStatus filters by authenticated user
    - listArchivedTasks filters by authenticated user
  </done>
</task>

<task type="auto">
  <name>Task 2: Add auth validation to all mutation functions</name>
  <files>convex/tasks.ts</files>
  <action>
1. Update `createTask` mutation to auto-assign userId:
   ```typescript
   export const createTask = mutation({
     args: {
       title: v.string(),
       description: v.optional(v.string()),
       status: statusValidator,
       priority: priorityValidator,
       tags: v.array(v.string()),
       dueDate: v.optional(v.number()),
       order: v.number(),
     },
     handler: async (ctx, args) => {
       const userId = await getAuthUserId(ctx);
       if (!userId) throw new Error("Not authenticated");

       if (args.title.trim() === "") {
         throw new Error("Title cannot be empty");
       }

       const now = Date.now();
       const taskId = await ctx.db.insert("tasks", {
         ...args,
         title: args.title.trim(),
         archived: false,
         updatedAt: now,
         userId,  // Auto-assign to authenticated user
       });

       await ctx.db.insert("activity_history", {
         taskId,
         field: "_created",
         oldValue: undefined,
         newValue: JSON.stringify({ title: args.title, status: args.status }),
         userId: userId.toString(),  // Now populated with real user ID
       });

       return await ctx.db.get(taskId);
     },
   });
   ```

2. Update `updateTask` mutation to validate ownership:
   ```typescript
   export const updateTask = mutation({
     args: {
       id: v.id("tasks"),
       updates: v.object({
         title: v.optional(v.string()),
         description: v.optional(v.string()),
         status: v.optional(statusValidator),
         priority: v.optional(priorityValidator),
         tags: v.optional(v.array(v.string())),
         dueDate: v.optional(v.number()),
         order: v.optional(v.number()),
       }),
     },
     handler: async (ctx, args) => {
       const userId = await getAuthUserId(ctx);
       if (!userId) throw new Error("Not authenticated");

       const existing = await ctx.db.get(args.id);
       if (!existing) throw new Error("Task not found");
       if (existing.userId !== userId) throw new Error("Not authorized");
       if (existing.archived) throw new Error("Cannot update archived task");

       // ... rest of existing update logic ...
       // Update activity_history inserts to use: userId: userId.toString()
     },
   });
   ```

3. Update `archiveTask` mutation to validate ownership:
   ```typescript
   export const archiveTask = mutation({
     args: { id: v.id("tasks") },
     handler: async (ctx, args) => {
       const userId = await getAuthUserId(ctx);
       if (!userId) throw new Error("Not authenticated");

       const task = await ctx.db.get(args.id);
       if (!task) throw new Error("Task not found");
       if (task.userId !== userId) throw new Error("Not authorized");

       await ctx.db.patch(args.id, {
         archived: true,
         updatedAt: Date.now(),
       });

       await ctx.db.insert("activity_history", {
         taskId: args.id,
         field: "archived",
         oldValue: JSON.stringify(false),
         newValue: JSON.stringify(true),
         userId: userId.toString(),
       });

       return { success: true };
     },
   });
   ```

4. Update `restoreTask` mutation to validate ownership:
   ```typescript
   export const restoreTask = mutation({
     args: { id: v.id("tasks") },
     handler: async (ctx, args) => {
       const userId = await getAuthUserId(ctx);
       if (!userId) throw new Error("Not authenticated");

       const task = await ctx.db.get(args.id);
       if (!task) throw new Error("Task not found");
       if (task.userId !== userId) throw new Error("Not authorized");
       if (!task.archived) throw new Error("Task is not archived");

       await ctx.db.patch(args.id, {
         archived: false,
         status: "backlog",
         updatedAt: Date.now(),
       });

       await ctx.db.insert("activity_history", {
         taskId: args.id,
         field: "archived",
         oldValue: JSON.stringify(true),
         newValue: JSON.stringify(false),
         userId: userId.toString(),
       });

       return await ctx.db.get(args.id);
     },
   });
   ```

Pattern: Every mutation now:
1. Gets userId via getAuthUserId(ctx)
2. Throws "Not authenticated" if null
3. For existing tasks: validates task.userId === userId before modifying
4. For new tasks: assigns userId automatically
5. Activity history logs real userId
  </action>
  <verify>
    - `npx convex dev --once` compiles and deploys
    - All mutation functions have `getAuthUserId(ctx)` call
    - createTask includes `userId` in insert
    - updateTask, archiveTask, restoreTask check `task.userId !== userId`
    - activity_history inserts use `userId: userId.toString()`
  </verify>
  <done>
    - createTask auto-assigns userId to new tasks
    - updateTask validates ownership before update
    - archiveTask validates ownership before archive
    - restoreTask validates ownership before restore
    - All activity_history entries include real userId
  </done>
</task>

</tasks>

<verification>
1. `npx convex dev --once` succeeds
2. Grep for "getAuthUserId" - should appear in all handlers
3. Grep for "Not authenticated" - should appear in all functions
4. Grep for "Not authorized" - should appear in get/update/archive/restore
5. Check createTask includes `userId` in insert object
</verification>

<success_criteria>
- All query functions require authentication (throw if not authenticated)
- All queries filter to only return user's own tasks
- All mutations require authentication
- Mutations on existing tasks validate user owns the task
- New tasks automatically assigned to authenticated user
- Activity history populated with real user IDs
</success_criteria>

<output>
After completion, create `.planning/phases/03-authentication/03-02-SUMMARY.md`
</output>
